第六天：

教学任务：

        第六章  高级特性, 共 39 个slide(132-171);

目标： 

------------------------------------------------------------

第六章： Advanced Language Features (132-171)

知识点：一. static修改符
	static修饰的方法或者属性,可以使用类.方法或者类.属性访问.
        还可以使用引用.方法或者引用.属性 但是不建议使用
        引用.的方式访问
	static修饰的方法或者代码块只能操作static修饰的变量
	一般变量不能直接被拿来使用,必须通过引用.属性来获得.
            static修饰符可以用来修饰类的成员变量、成员方法和代码块。
            . 用static修饰的成员变量表示静态变量，可以直接通过类名来访问；
            . 用static修饰的成员方法表示静态方法，可以直接通过类名来访问；
            . 用static修饰的程序代码表示静态代码块，当Java虚似机加载类时(调用时)，就会执行该代码块；

            被static所修饰的成员变量和成员方法表明归某个类所有，它不依赖于类的特定实例，被类的所有实例共享。只要这个类被
            加载，Java虚拟机就能根据类名在运行时数据区的方法区内定位到它们。

            1. static 变量

               成员变量：定义在类里面、方法外面的变量, 分两种：
                         a. 实例变量;
                         b. 静态变量；形式和实例变量类似，在实例变量前面加static关键字；

               static变量和实例变量的区别：
               . static变量对于每个类而言在内存中只有一个，位于方法区，能被类的所有实例所共享；实例变量对于每个类的每个实例都有一份，
                 它们之间互不影响；
               . Java虚拟机在加载类的过程中为static变量分配内存，实例变量在加载完类后创建对象时分配内存；
	       . main方法和被测试类不是位于同一个类时，只有在调用测试类的一些操作是static{}代码块才会马上被执行；如果main和被测试类位于同一个类时，static{}一开始就被执行
               . static变量存在方法区，实例变量存在堆区；
               . static变量可以直接通过类名访问，实例变量通过引用类型变量访问；
*类中方法的执行顺序(代码按顺序执行)
static{}代码块->如果是static Test t1 = new Test()
因为获得了new对象，先执行普通代码块(按照代码顺序)，再执行构造器
->如果是static int x = method()(method是静态方法)，直接执行method方法中的内容
->如果后面再没有static修饰的内容执行main方法，其中如果再遇到new对象，还是先执行普通代码块，再按照代码顺序执行
	       

               举例： public class Counter {
                             public int count1 = 0;
                             public static int count2 = 0;
			     public Counter() {
				counter1++;
				counter2++;
			     }	
                             public static void main(String[] args) {
                                    Counter counterA = new Counter();
                                    Counter counterB = new Counter();
                                    counterA.count1;  1
                                    counterA.count2;  2 
									counterB.count1;  1
                                    counterB.count2;  2
                             }
                      }

                      通过内存图讲解以上代码.

               按课件上内容一条条讲解，以及详细讲解课件示例程序；

               课堂练习：1) 带着做：统计一个类创建实例的个数；
                         2) 自行练习： ?????????????????????///
		  	    买票   A(票价5折)  B(票价7折)   Person per =  new Person() / 
										new A()/new B()         
					class Person { 
			  		 		 per.买票()
    						public void  买票(){
	  							输出不打折
						}			 		
					} 			    
				 	class A extends Person {  
   						 public void 买票() {    switch(name) {
								  输出打5折
   					 }				
					case “zhangsan”: {
				  		Person per = new B();
				    				per.买票();
				  	break;
					}
					case “lisi” ： ｛
				 	  Person per = new A();
				   		 per.买票();
				         break;				｝
					 }					
					}
				default : {
				   Person per = new Person();
				   per.买票();
				}  
			}

			class B extends Person {
  				  public void 买票() {
					 输出打7折
				}
			}
                  
            2. static 方法

               成员方法分为静态方法和实例方法。用static修饰的方法叫静态方法，或类方法。静态方法也和静态变量一样，不需要创建类的实例，可以直接通过类名来访问。

               public class Sample1 {
                     public static int add(int x, int y) {
                            return x+y;
                     }
               }

               public class Sample2 {
                     public void method() {
                            int result = Sample1.add(1,2);
                            System.out.println("result= " + result);
                     }
               }
               a. static方法 main可以直接访问所属类的引用的实例变量和
		  类的引用的实例方法，直接访问所属类的静态变量和静态方法；

                  注：1) 不能使用this，super关键字；
                      2) 静态方法必须被实现。静态方法用来表示某个类所特有的功能，这种功能的实现不依赖于类的具体实例，也不依赖于它的子类。既然如此，当前类必须为静态方法提供实现。
		public void add(){}:此方法是一个实现的方法,
				只不过方法的方法体为null 空实现
      	  	public void add();:此方法是没有被实现的方法.
				只能出现在抽象类或者接口中.
               b. 父类的静态方法不能被子类覆为非静态方法。以下代码编译出错。

                  public class Base {
                         public static void method() {}
                  }

                  public class Sub extends Base {
                         public void method() {}//编译出错
                  }

                  子类可以定义与父类的静态方法同名的静态方法，以便在子类中隐藏父类的静态方法。子类的静态方法也要满足覆盖条件。

                  子类隐藏父类的静态方法和子类覆盖父类的实例方法，区别在于：运行时，JVM把静态方法和所属的类绑定，而把实例方法和所属的实例绑定。

               c. 父类的非静态方法不能被子类覆盖为静态方法；
static方法只考虑编译类型，不考虑运行时类型，换言之子类继承父类时，父类static方法在调用时，子类即使重写了也不能被执行。如果想要执行子类的static方法，只能用子类的名称.static方法
            3. static 代码块                  

               类中可以包含静态代码块，它不存于任何方法中。在Java虚拟机中加载类时会执行这些静态代码块。如果类中包含多个静态代码块，那么Java虚拟机将按照它们在类中出现的顺序依次执行它们，每个静态代码块只会被执行一次。

               public class Sample {
                   static int i = 5;
                   static {//第一个静态代码块
                          System.out.println("First Static code i="+i++);
                   }
                   static {//第二个静态代码块
                          System.out.println("Second Static code i="+i++);
                   }
                   public static void main(String[] args) {
                          Sample s1 = new Sample();
                          Sample s2 = new Sample();
                          System.out.println("At last, i= "+i);
                   }
               }
					输出：i=7
					
					
               类的构造方法用于初始化类的实例，而类的静态代码块则可用于初始化类，给类的静态变量赋初始值。

               静态代码块与静态方法一样，也不能直接访问类的实例变量和实例方法，而必须通过实例的引用来访问它们。

        二. final修改符

               final具有"不可改变的"含义，它可以修饰非抽象类、非抽象成员方法和变量。
               . 用final修饰的类不能被继承，没有子类；
               . 用final修饰的方法不能被子类的方法覆盖；
               . 用final修饰的变量表示常量，只能被赋一次值；
					构造方法本身不能被继承,所以不能被重写
					final修饰的方法不能被重写
					构造方法不需要final修饰时已经实现不能重写的效果,所以不需要final修饰.

               final不能用来修饰构造方法，因为"方法覆盖"这一概念仅适用于类的成员方法，而不适用于类的构造方法，父类的构造方法和子类的构造方法之间不存在覆盖关系. 因此用final修饰构造方法是无意义的。父类中用private修饰的方法不能被子类的方法覆盖，因此private类型的方法默认是final类型的。

               1. final类

                  继承关系的弱点是打破封装，子类能够访问父类的实现细节，而且能以方法覆盖的方式修改实现细节。在以下情况下,
                  可以考虑把类定义为final类型，使得这个类不能被继承。

                  . 子类有可能会错误地修改父类的实现细节；
                  . 出于安全，类的实现细节不允许有任何改动；
                  . 在创建对象模型时，确信这个类不会再被扩展；

                  例如JDK中java.lang.String类被定义为final类型；

               2. final方法；
 
                  某些情况下，出于安全原因，父类不允许子类覆盖某个方法，此时可以把这个方法声明为final类型。例如在
                  java.lang.Object类中，getClass()方法为final类型。

               3. final变量：

                  a. final可以修饰静态变量、实例变量、局部变量；
                  b. final变量都必须显示初始化，否则会导致编译错误；
                     1) 静态变量，只能在定义变量时进行初始化；
                     2) 实例变量，可以在定义变量时，或者在构造方法中进行初始化；
                  c. final变量只能赋一次值。

                     public class Sample {
                            private final int var1 = 1;
                            public Sample() {
                                 var1 = 2;                //编译出错，不允许改变var1实例变量的值；
                            }

                            public void method(final int param) {
                                 final int var2 = 1;         
                                 var2++;                  //编译出错，不允许改变var2局部常量的值
                                 param++;                 //编译出错，不允许改变final类型参数的值；
                            }
                     }

                     public class Sample {
                            final int var1;               //定义var1实例常量
                            final int var2 = 0;           //定义并初始化var2实例常量
                            Sample() {
                                  var1 = 1;               //初始化var1实例常量
                            }
			final修饰的成员变量必须显示初始化,如果没有初始化
			可以在构造器进行初始化.需要注意,此时构造方法必须只能有一个
			.如果存在多个,很可能调用的构造器是没有初始化变量的那个构造器
			.换言之变量永远没有初始化,违反了final原则.
			但是父类的构造器只能是无参构造器,如果不存在子父类
			父类可以有人任意一个构造器.
                            Sample() {
                                  var2= 2;                //初始化var1实例常量
                            }
                     }                     

        三. abstract修改符

            可用来修饰类和成员方法。
            . 用abstract修饰的类表示抽象类，抽象类不能实例化，即不允许创建抽象类本身的实例。没有用abstract修饰的类称为具体类，具体类可以被实例化。
            . 用abstract修饰的方法表示抽象方法，抽象方法没有方法体。抽象方法用来描述系统具有什么功能，但不提供具体的实现。
              没有abstract修饰的方法称为具体方法，具体方法具有方法体。
	     子类继承抽象的父类.需要注意如果父类中包含抽象方法,子类在继承时又没有重写父类的
	     抽象方法.此时子类必须也声明称抽象类.否则报错.
	     原因:子类继承父类 会将父类的抽象方法也继承过去,此时子类包含抽象方法.包含抽象方法的类必须声明为抽象类.所以子类要声明成abstract或者显示重写父类的抽象方法.

	     存在抽象方法一定是抽象类,抽象类不一定包含抽象方法
	     抽象类只有被继承才能被使用.  
	     abstract class Person {
  		 public abstract void eat();
	     }
	     class Employee extends Person {
 		 public  void eat() {
			System.out.println(“吃饱”)
  		 }
	     }
	     class Boss extends Person {
 		 public  void eat() {
 			System.out.println(“吃好”);
  		}
	     }
	     构造方法不能重写,不能被继承
	     final修饰的方法也不能被重写.
	     abstract修饰的方法需要被重写.
	     如果abstract修饰构造方法或者final修饰的方法 .
	     构造方法就不能确定到底是需要被重写还是不能被重写.
	     final方法也不能确定是到底需要被重写还是不呗重写.

	    abstract不能与final static 以及构造方法并存
            语法规则；
            1) 抽象类中可以没有抽象方法，但包含了抽象方法的类必须被定义为抽象类；
            2) 没有抽象构造方法，也没有抽象静态方法；
             abstract和static 不允许同时存在
	    3) 抽象类中可以有非抽象的构造方法；
            4) 抽象类及抽象方法不能被final修饰符修饰。

            抽象类不允许实例化：假设允许抽象化，调用抽象类中的抽象方法将执行什么方法体内容？

	    抽象类就如他的名字一样是抽象的，他里面的方法都是没有方法体的，也就是没有实际的实现代码，而实例化后的对象是类的一个实体对象，
	是可以调用他的方法完成一些功能的，一个抽象类的方法没有方法体（半成品，呵呵），当然不能实例化了

        四. 接口

            接口使用的目的：解决多重继承问题；例如Fish类继承Animal类，表明Fish是一种动物，但鱼同样也是一种食物，如何表示这种关系呢？ 由于Java语言不支持一个类有多个直接的父类，因此无法用继承关系来描述鱼既是一种食物，又是一种动物，为了解决这一问题，Java语言引入接口类型，简称接口。一个类只能有一个直接的父类，但是可以实现多个接口。 采用这种方式，Java语言对多继承提供了有力的支持。
	    java支持单继承多实现.
		extends implements
            1. 接口是抽象类的另外一种形式

               接口是抽象类的抽象，抽象类可存在有方法体的方法，接口中的方法全部为抽象方法；

            2. 接口中的所有方法均是抽象方法， 默认都是public、abstract类型的；

               public interface A {
                      public abstract void method1();                //合法，默认为public、abstract类型
                      public abstract void method2(); //合法，显示声明为public、abstract类型

            3. 接口中的成员变量默认都是public, static, final类型，必须被显式初始化；
               public interface A {
                      int CONST = 1;               //合法，CONST默认为public, static, final类型
                      public static final int OPAQUE = 1;  //合法，显示声明为public static final 类型
               }
 
            4. 接口中只能包含public, static, final类型成员变量和public、abstract类型的成员方法；
            5. 接口中没有构造方法，不能被实例化。
            6. 一个类只能继承一个直接的父类，但能实现多个接口。
		当一个子类实现了多个接口,需要注意使用接口来指向子类时,一个接口只能调用自己给予子类的方法
		e.g 
			class C implements A,B 
			A a = new C();
			B b = new C();
			此时a只能调用接口A给予C的方法,不能调用接口B给予C的方法
			同理
			此时b只能调用接口B给予C的方法,不能调用接口A给予C的方法
            抽象类和接口比较：

            1. 相同点：
               a. 都不能被实例化；
               b. 都能包含抽象方法；
            2. 不同点；
               a. 抽象类中可以为部分方法提供默认的实现，从而避免子类中重复实现它们，提高代码的可重用性，
                  而接口中只能包含抽象方法；
               b. 一个类只能继承一个直接的父类，这个父类有可能是抽象类；但一个类可以实现多个接口，这是接口的优势所在。

        五. 访问控制
	   通过修饰符的控制来判断哪些值用户可以访问,哪些值用户不能访问.
            面向对象的基本思想之一是封装实现细节并且公开方法。Java语言采用访问控制修饰符来控制类及类的方法和变量的访问权限，从而只向使用者暴露方法，但隐藏实现细节。
	    访问控制分4种级别。

            访问级别       访问控制修饰符        同类       同包       子类(不同包)      不同的包
            公开级别：       public               y          y          y          y
            受保护           protected            y          y          y
            默认           default没有访问控制符  y          y
            私有             private              y
子类继承父类，如果调用时，使用过的是父类的引用个指向子类的实例对象，此时体现的是java的多态，只要的是用来调用方法，没有体现继承关系
如果想要体现继承关系，需要直接构建子类的应用指向子类的实例对象，此时体现的java的继承关系
eg.Student extends Person
person p = new Student(此时体现多态，调用方法)
Student s = new Student(此时体现继承，可以调用父类变量)

            成员变量、成员方法和构造方法可以处于4个访问级别中的一个；
            类的访问控制符有两种：public, default(默认的，什么都不用写)  default就是包内访问控制符来
		
	    java中的数据类型，可分为两类： 
	    1.基本数据类型，也称原始数据类型。byte,short,char,int,long,float,double,boolean 
  		他们之间的比较，应用双等号（==）,比较的是他们的值。 
	    2.复合数据类型(类) 
  		当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的		基类中定义了一个equals的方法，equals这个方法的初始行为是比较对象的内存地址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。equals比较两个对象之间的值
  		对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。
          原来，程序在运行的时候会创建一个字符串缓冲池当使用 s2 = "Monday" 这样的表达是创建字符串的时候，程序首先会在这个String缓冲池中寻找相同值的对象，在第一个程序中，s1先被放到了池中，所以在s2被创建的时候，程序找到了具		有相同值的 s1
		将s2引用s1所引用的对象"Monday"
		第二段程序中，使用了 new 操作符，他明白的告诉程序："我要一个新的！不要旧的！"于是一个新的"Monday"Sting对象被创建在内存中。他们的值相同，但是位置不同.
	 原 来，（java.lang.String的intern()方法"abc".intern()方法的返回值还是字符串"abc"，表面上看起来好像这个方 法没什么用处。但实际上，它做了个小动作：检查字符串池里是否存在"abc"这么一个字符串，如果存在，就返回		池里的字符串；如果不存在，该方法会 把"abc"添加到字符串池中，然后再返回它的引用。）	 
		必须明确equals到底比较的是对象的什么？查看Object类的equals方法源码：
 		public boolean equals(Object obj) {
 			return (this == obj);
    		}
	        发现内部使用的也是 == 运算符比较的。
		所以在对象的比较相同上 == 和equals是一样的。

		那有的同学就问了，那equals方法还有什么用呢？

		虽然每个对象都有自己的内存地址，但是每个对象也有自己的一些特有的特征。
		比如学生对象有自己的姓名和年龄，希望根据姓名和年龄的相同来判断学生对象是否相同。

		这时使用Object类的equals就不能满足需求了，
		就需要通过覆盖equals的方式，建立学生对象比较相同的具体内容	  
		两个对象进行比较,如果使用equals.同样是比较两个对象的地址.
		此时如果调用的两个对象分别赋予相同的名字
		e.g
		Student stu1 = new Student(“tom”)
		Student stu2 = new Student(“tom”);
		由于equals比较的是对象的地址.返回为false表示两个不相同对象。实际当前名称
		相同的对象时,希望返回相同的对象。此时equals没办法完成职能需要进行重写
		重写后比较对象所对应的值
		e.g
		public boolean equals(Object obj) {
			if(obj instanceof Student) {
			Student stu = (Student)obj;
		}
		}
		equals方法是api定义好的,不允许自定义.接受的参数只能是Object类型,
		所以需要进行强制类型转换。Object转换成Student类型.大范围转小范围
		转之前先进行instanceof判断.判断通过进行强制转换.
		在进行name比较
		String name = stu.name;
		String name2 = this.name;
		name.equals(name2)
		此时equals使用的是api定义好的 相当于 String.equals(String)比较
		的是内容 所以返回为true.


	六. 内部类

            在一个类的内部定义的类称为内部类。内部类允许把一些逻辑相关的类组织在一起，并且控制内部类代码的可视性。对于初
            学者而言，内部类似乎有多条，但是随着内部类的逐步了解，就会发现它有独到的用途。它能够让程序结构变得更优雅。

            变量按照作用域可分为：

            1) 成员变量: 实例变量、静态变量；
            2) 局部变量；

            同样，内部类按照作用域可分为；
               
            1) 成员内部类: 实例内部类、静态内部类；
            2) 局部内部类；

            顶层类只能处于public和默认访问级别，而成员内部类可以处于public, protected, private和默认这4种访问级别；

            1.  静态内部类；

                是成员内部类的一种，用static修饰。静态内部类具有以下特点：

                1)  静态内部类的实例不会自动持有外部类的特定实例的引用，在创建内部类的实例时，不必创建外部类的实例。
                    class A {
                          public static class B{
                                 int v;
								static int v2;
                          }
                    }

                    class Tester {
                          public void test() {
                                 A.B b = new A.B();
                                 b.v = 1;
								A.B.v2 = 2;
                          }
                    }

                 2) 静态内部类可以直接访问外部类的静态成员，如果访问外部类的实例成员，就必须通过外部类的实例去访问。

                    class A {
                          private int a1;              //实例变量a1
                          private static int a2;       //静态变量a2
 
                          public static class B {
                                 int b1 = a1;          //编译错误，不能直接访问外部类A的实例变量a1
                                 int b2 = a2;          //合法，可以直接访问外部类A的静态变量a2
                                 int b3 = new A().a1;  //合法，可以通过类A的实例访问变量a1
                          }
                    }

                 3) 在静态内部类中可以定义静态成员和实例成员。

                    class A {
                          public static class B {
                                 int v1;                       //实例变量
                                 static int v2;                //静态变量

                                 public static class C {
                                        static int v3;         //静态内部类
                                 }
                          }
                    }
                  
                 4) 可以通过完整的类名直接访问静态内部类的静态成员。

                    class A {
                          public static class B {
                                 int v1;                       //实例变量
                                 static int v2;                //静态变量

                                 public static class C {
                                        static int v3;         //静态内部类
                                        int v4;
                                 }
                          }
                    }

                    public class Tester {
                          public void test() {
                                 A.B b = new A.B();
                                 A.B.C c = new A.B.C();
                                 b.v1 = 1;
                                 b.v2 = 1;
                                 A.B.v1 = 1;             //编译错误
                                 A.B.v2 = 1;             //合法
                                 A.B.C.v3 = 1;           //合法
								c.v4 = 1; 
			 }
                    }

            2.  实例内部类；

                成员内部类的一种，没有static修饰符。特点：

                1) 在创建实例内部类的实例时，外部类的实例必须已经存在。

                   Outer.InnerTool tool = new Outer().new InnerTool();

                   等价于：

                   Outer outer = new Outer();
                   Outer.InnerTool tool = outer.new InnerTool();

                   以下代码会导致编译错误：

                   Outer.InnerTool tool = new Outer.InnerTool();

                2) 实例内部类的实例自动持有外部类的实例的引用。在内部类中， 可以直接访问外部类的所有成员，包括
                   成员变量和成员方法。

                   public class A {
                          private int a1;
                          public int a2;
                          static int a3;
                          public A(int a1, int a2) {
                                 this.a1 = a1;
                                 this.a2 = a2;
                          }
                          protected int methodA() {
                                 return a1*a2;
                          }

                          class B {
                                int b1 = a1;               //直接访问private的a1
                                int b2 = a2;               //直接访问public的a2
                                int b3 = a3;               //直接访问static的a3
                                int b4 = new A(3,4).a1;    //访问一个新建的实例A的a1
                                int b5 = methodA();        //访问methodA()方法
                          }

                          public static void main(String args[]) {
                                 A.B b = new A(1,2).new B();
                                 System.out.println("b.b1="+b.b1);    //打印b.b1=1;
                                 System.out.println("b.b2="+b.b2);    //打印b.b2=2;
                                 System.out.println("b.b3="+b.b3);    //打印b.b3=0;
                                 System.out.println("b.b4="+b.b4);    //打印b.b4=3;
                                 System.out.println("b.b5="+b.b5);    //打印b.b5=2;
                          }
                    }                 

                3) 外部类实例与内部类实例之间是一对多的关系，一个内部类实例只会引用一个外部类实例，而一个外部类实例
                   对应零个或多个内部类实例。在外部类中不能直接访问内部类的成员，必须通过内部类的实例去访问。         

                   class A {
                         class B {
                               private int b1 = 1;
                               public int b2 = 2;
                               class C{}
                         }

                         public void test() {
                                int v1 = b1;                          //invalid
                                int v2 = b2;                          //invalid
                                B.C c1 = new C();                     //invalid

                                B b = new B();
                                int v3 = b.b1;                          //valid
                                int v4 = b.b2;                          //valid
                                B.C c2 = b.new C();                     //valid                       
                                B.C c3 = new B().new C();               //valid  
                         }
                   }

                4) 实例内部类中不能定义静态成员，而只能定义实例成员。         
                5) 如果实例内部类B与外部类A包含同名的成员，那么在类B中， this.v表示类B的成员， A.this.v表示类A的成员。  

            3.  局部内部类；

                在一个方法中定义的内部类，它的可见范围是当前方法。和局部变量一样，局部内部类不能用访问控制修饰符
                (public, private和protected)及static修饰符来修饰。特点：

                1) 局部内部类只能在当前方法中使用。
                   class A {
                         B b = new B();                 //编译错误；
                         public void method() {
                                class B{
                                      int v1;
                                      int v2;
    
                                      class C {
                                            int v3;
                                      }
                                }
                                B b = new B();                 //合法
                                B.C c = b.new C();             //合法
                         }
                   }

                2) 局部内部类和实例内部类一样，不能包含静态成员。
                   class A {
                         public void method() {
                                class B{
                                      static int v1;           //编译错误
                                      int v2;                  //合法

                                      static class C {         //编译错误
                                             int v3;
                                      }
                                }
                         }
                   }
                
                3) 在局部内部类中定义的内部类也不能被public、protected和private这些访问控制修饰符修饰；
                4) 局部内部类和实例内部类一样，可以访问外部类的所有成员，此外，局部内部类还可以访问所在方法中的final类型
                   的参数和变量。

                几种内部类的区别：
                1. 创建
                   a. 声明的位置: 
                      静态内部类：类的内部，方法的外部，用static关键字修饰；
                      实例内部类：类的内部，方法的外部，不用static关键字修饰；
                      局部内部类：方法的内部；
                      匿名内部类：既可以在类的内部，方法的外部，也可以在方法的内部；
                      
                   b. 实例化方式:
                      静态内部类：new Outer.Inner();          	//在外部类外创建；
                                  new Inner();                	//在外部类内内部类外创建
                      实例内部类：new Outer().new Inner();      //在外部类外创建；
                                  this.new Inner();             //在外部类内内部类外创建 
                      局部内部类：new Inner();                  //只能在方法内部创建；                                  
                      匿名内部类：new 类名() {};            
         
                2. 访问
                   a. 外部类访问内部类：
                      静态内部类：通过完整的类名直接访问静态内部类的静态成员;
                      实例内部类：通过内部类的实例去访问内部类的成员;
                      局部内部类：不能访问；
                      匿名内部类：不能访问；

                   b. 内部类访问外部类：
                      静态内部类：直接访问外部类的静态成员；
                      实例内部类：可以直接访问外部类的所有成员;
                                  如果实例内部类B与外部类A包含同名的成员，那么在类B中， this.v表示类B的成员，
                                  A.this.v表示类A的成员。
                      局部内部类：可以直接访问外部类的所有成员, 访问所在方法中的final类型的参数和变量；
                      匿名内部类：可以直接访问外部类的所有成员, 访问所在方法中的final类型的参数和变量；



        七. 包装类
AutoBoxing
------------------------
primitive type			wrapper type
int				Integer
byte				Byte
long				Long
boolean				Boolean
short				Short
char				Character
double				Double
float				Float
new 装箱 基本类型转换成封装类型
valueOf() 拆箱 封装类型转换成基本类型.                        

String—>int 需要注意 String包括的内容只能是数字类型,如果是字母类型
编译能通过.但是在运行阶段会报错.
            作用：1) 用引用类型表示数值；例如表示一个缺考学生的成绩；
                  2) 有些场合必须要引用类型；例如集合中只能存储引用类型；
                  3) 实现基本类型间以及与字符串间转换；

                     public static Integer valueOf(int i);
                     public static Integer valueOf(String s) throws NumberFormatException;

                     public static int parseInt(String s) throws NumberFormatException;
                     public static String toString(int i);


                     int     ->  String : toString(int i) 
                     Integer ->  String : toString() 
                     String  ->  int    :Integer.parseInt(String s)
                     Integer ->  int    : intValue();
                     int     ->  Integer: valueOf(int i)
                     String  ->  Integer: valueOf(String s)

1.基本类型只能按值传递，而每个基本类型对应的封装类是按引用传递的。 
2.从性能上说java中的基本类型是在堆栈上创建的，而所有的对象类型都是在堆上创建的，（对象的引用在堆栈上创建）。比如 
Integer i=new Integer(10); 其中new Integer()是在堆上创建的，而他的引用Integer i是在堆栈上。 
封装类的出现，是为了更方便的使用一些基本类型不具备的方法，比如valueOf（），toString（）等等。
还有你如果想传递一个int对象的引用，而不是值，那只能用封装类。 
在堆栈上分配内存的调用效率和在堆上分配内存的效率差太多了。虽然在堆栈上分配内存效率高，不过在堆栈上分配内存有内存泄露的问题。
（这是一个平庸程序员基本解决不了的问题...）java用了一种很天才的方法提高了在堆上分配内存的效率，尽管如此，java还是慢。
他不太可能达到向c++那么快，尽管他一直在承诺总有一天虚拟机会和机器码速度一样快。

JDK5.0开始可以自动封包了 ，也就是基本数据可以自动封装成封装类,基本数据类型的好处就是速度快（不涉及到对象的构造和回收），
封装类的目的主要是更好的处理数据之间的转换，方法很多，用起来也方便。 

当然，封装类型的传递是引用传递，比如 
Integer a = new Integer(1);  
表示一个Integer类型的引用a引用了一块内存，这块内存中的数据是1; 而a中所存的则是这块内存的引用（地址），
把a传给别的方法或对象时，则是把a的引用传递过去了。 

类型之间的转换: 
String b = "123456"; 
int c = Integer.parseInt(b); 
表示把字符串123456转成整型数字,其中parseInt是静态方法，可以直接使用 

还有一点，在某些场合，需要用到封装类，比如一个集合List，它只能往里面添加对象，也就是Object,那么直接存数字肯定是不行 的，
则需要将数字封装成封装类型对象再存到该List中，如 
List list = new ArrayList(); 
list.add(new Integer(1)); 
list.add(new Integer(2)); 
list.add(new Integer(3)); 
list.add(new Integer(4)); 
JDK5.0以后可以自动封包，所以可以简写成 
List list = new ArrayList(); 
list.add(1); 
list.add(2); 
list.add(3); 
list.add(4);	

增强的for循环
for循环的格式:
int[] iarray = new int[]{1,2,3,4}
for(遍历的每一项对应的类型(Object) 每一项的别名(随便起)obj:遍历的引用iarray) {
	Integer i = (Integer)obj;
	System.out.println(i)
}
for(int i:iarray) {
	System.out.println(i);	
}
增强的for循环不需要构建变量,相对原始for简易.
但是需要注意2点
1.最好构建成Object类型 进行强制类型转换
2.因为没有构建变量,所以不能获取其中的某一个值
原始for循环
for(int i=0;i<iarray.length;i++) {
	System.out.println(iarray[i]);
}

	   八. 集合   

            由数组的缺点引出集合: 

            数组的长度是固定的，在许多应用场合，一组数据的数目是不固定的，比如一个单位的员工数目是变化的，有老的员工跳槽，也有新的员工进来。比如一个单位的客户是变化的，有老的客户流失，也有新的客户签单。

            为了使程序能方便地存储和操纵数目不固定的一组数据，JDK类库提供了Java集合，所有Java集合类都位于java.util包中。
            与Java数组不同，Java集合中不能存放基本类型数据，而只能存放对象的引用。出于表达上的便利，下面把“集合中的对象的引用”简称为“集合中的对象“。
List list = new ArrayList();
Set set = new HashSet();
            Java中集合主要分为三种类型：

            . Set : 无序，并且没有重复对象。
            . List: 有序(放入的先后的次序), 可重复。
            . Map : 集合中的每一个元素包含一对键对象和值对象，集合中没有重复的键对象(相同
		    键对应的值，后一个覆盖前一个)，值对象可以重复。

            1. Collection和Iterator接口

               在Collection接口中声明了适用于Set和List的通用方法：

               boolean add(Object o)          : 向集合中加入一个对象的引用；
               void clear()                   : 删除集合中的所有对象引用，即不再持有这些对象的引用；
               boolean contains(Object o)     : 判断在集合中是否持有特定对象的引用；
               boolean isEmpty()              : 判断集合是否为空；
               Iterator iterator()            : 返回一个Iterator对象，可用它来遍历集合中的元素；
               boolean remove(Object o)       : 从集合中删除一个对象的引用；
               int size()                     : 返回集合中元素的数目；
               Object[] toArrray()            : 返回一个数组，该数组包含集合中的所有元素；

               Iterator接口隐藏底层集合的数据结构，向客户程序提供了遍历各种类型的集合的统一方法。Iterator接口中声明方法：

               hasNext()                      : 判断集合中的元素是否遍历完毕，如没有，就返回true;
               next()                         : 返回下一个元素；

               通过下面程序实践上面的方法：

               import java.util.*;
               public class Visitor {
                      public static void print(Collection c) {
                             Iterator it = c.iterator();
                             while(it.hasNext()) {
                                    Object element = it.next();
                                    System.out.println(element);
                             }
                      }

                      public static void main(String args[]) {
                             Set set = new HashSet();
                             set.add("Tom");
                             set.add("Mary");
                             set.add("Jack");
                             print(set);

                             List list = new ArrayList();
                             list.add("Linda");
                             list.add("Mary");
                             list.add("Rose");
                             print(list);

                             Map map = new HashMap();
                             map.put("M","男");
                             map.put("F","女");
                             print(map.entrySet());
                     }
               }

            2. Set

               最简单的一种集合，集合中的对象无序、不能重复。主要实现类包括：
         
               . HashSet      : 按照哈希算法来存取集合中的对象，存取速度比较快；
               . LinkedHashSet: HashSet子类，不仅实现Hash算法，还实现链表数据结构，链表数据结构能提高插入和删除元素的性能；
               . TreeSet      : 实现SortedSet接口，具有排序功能；

               一般用法：

               Set集合中存放的是对象的引用，并且没有重复对象。

               Set set = new HashSet();
               String s1 = new String("hello");
               String s2 = s1;
               String s3 = new String("world");
               set.add(s1);
               set.add(s2);
               set.add(s3);
               System.out.println(set.size());

               当一个新的对象加入到Set集合中时，Set的add方法是如何判断这个对象是否已经存在于集合中的呢？它遍历既存对象，通过equals方法比较新对象和既存对象是否有相等的。

               boolean isExist = false;
               Iterator it = set.iterator();
               while(it.hasNext()) {
                     String oldStr = it.next();
                     if(newStr.equals(oldStr)) {
                            isExists = true;
                            break;
                     }
               }

               举例：Set set = new HashSet();
                     String s1 = new String("hello");
                     String s2 = new String("hello");
                     set.add(s1);
                     set.add(s2);
                     System.out.println(set.size());                         //集合中对象数目为1;

                1) HashSet
                  
                  按照哈希算法来存取集合中的对象，存取速度比较快。当向集合中加入一个对象时，HashSet会调用对象的hashCode()方法来获得哈希码，然后根据这个哈希码进一步计算出对象在集合中的存放位置。
在实际问题中，按照给定的值进行数据查询是经常遇到的，比如，在电话号码簿中查询某个人的电话号码；在图书馆中按照ISBN 编号查找某本书的位置；在地图中按照坐标查找某个地点的地名等等。为此，人们创造了一种能够根据记录的关键码 ( 也就是用以标识数据在记录中的存放位置的数据项 ) 方便的检索到对应的记录信息的数据结构，这就是字典 ( Dictionary ) 。

2.2.1字典的定义
我们都使用过字典，如英汉字典、成语字典，图书的检索目录、电话簿等也可以看作广义上的字典。在计算机科学中，把字典也当成一种数据结构。
我们把字典定义为“键- 值对” (Key-Value Pair) 的集合。根据不同的问题，我们为名字和值赋予不同的含义，比如，在英汉字典中，英文单词是名字，此单词的中文解释条目是值；在电话簿中，人名是名字，此人名对应的电话号码是值。
字典最基本的操作包括：find( 查找 ) 、 add( 插入 ) 、 remove( 删除 ) ，分别用来从字典中检索数据、插入数据和删除数据。在实际存储中，我们将“键 - 值对”存储于记录中，通过键 ( 也就是“键 - 值对”中的名字 ) 来标识该“键 - 值对”。“键 - 值对”的存放位置和其键之间的对应关系用一个二元组表示： ( 键 , 值的位置 ) 。
从字典中查找“键- 值对”的最简单方法就是使用数组存储，然后在查找的时候遍历此数组，当遍历到和被查找的“键 - 值对”的名字相同项的时候，这个“键 - 值对”就被找到了。这种最朴实的方式肯定是不能满足实际要求的，因此人们发明了一种检索效率非常高的组织字典数据的方法 ，即哈希表结构。
2.2.2哈希表与哈希方法
哈希方法在“键- 值对”的存储位置与它的键之间建立一个确定的对应函数关系 hash() ，使得每一个键与结构中的一个唯一的存储位置相对应：
存储位置=hash( 键 )
在搜索时，首先对键进行hash 运算，把求得的值当做“键 - 值对”的存储位置，在结构中按照此位置取“键 - 值对”进行比较，若键相等，则表示搜索成功。在存储“键 - 值对”的时候，依照相同的 hash 函数计算存储位置，并按此位置存放，这种方法就叫做哈希方法，也叫做散列方法。在哈希方法中使用的转换函数 hash 被称作哈希函数 ( 或者散列函数 ) 。按照此中算法构造出来的表叫做哈希表 ( 或者散列表 ) 。
哈希函数建立了从“键- 值对”到哈希表地址集合的一个映射，有了哈希函数，我们就可以根据键来确定“键 - 值对”在哈希表中的位置的地址。使用这种方法由于不必进行多次键的比较，所以其搜索速度非常快，很多系统都使用这种方法进行数据的组织和检索。
举一个例子，有一组“键值对”：<5, ” tom ” >、 <8, ” Jane ” >、 <12, ” Bit ” >、 <17, ” Lily ” >、 <20, ” sunny ” >，我们按照如下哈希函数对键进行计算 :hash(x)=x%17+3 ，得出如下结果： hash(5)=8 、 hash(8)=11 、 hash(12)=15 、 hash(17)=3 、 hash(20)=6 。我们把 <5, ” tom ” >、 <8, ” Jane ” >、 <12, ” Bit ” >、 <17, ” Lily ” >、 <20, ” sunny ” >分别放到地址为 8 、 11 、 15 、 3 、 6 的位置上。当要检索 17 对应的值的时候，只要首先计算 17 的哈希值为 3 ，然后到地址为 3 的地方去取数据就可以找到 17 对应的数据是“ Lily ”了，可见检索速度是非常快的。
2.2.3冲突与冲突的解决
通常键的取值范围比哈希表地址集合大很多，因此有可能经过同一哈希函数的计算，把不同的键映射到了同一个地址上面，这就叫冲突。比如，有一组“键- 值对”，其键分别为 12361 、 7251 、 3309 、 30976 ，采用的哈希函数是：
public static int hash(int key)
{
return key%73+13420;
}
则将会得到hash(12361)=hash(7251)=hash(3309)=hash(30976)=13444 ，即不同的键通过哈希函数对应到了同一个地址，我们称这种哈希计算结果相同的不同键为同义词。
如果“键- 值 对”在加入哈希表的时候产生了冲突，就必须找另外一个地方来存放它，冲突太多会降低数据插入和搜索的效率，因此希望能找到一个不容易产生冲突的函数，即构 造一个地址分布比较均匀的哈希函数。常用的哈希函数包括：直接定址法、数字分析法、除留余数法、乘留余数法、平方取中法、折叠法等。应该根据实际工作中关 键码的特点选用适当的方法
  
我们还应该注意，Java语言对equals()的要求如下，这些要求是必须遵循的： 
? 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。 
? 反射性：x.equals(x)必须返回是“true”。 
? 类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。 
? 还有一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。 
? 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。 
以上这五点是重写equals()方法时，必须遵守的准则，如果违反会出现意想不到的结果，请大家一定要遵守

equals()相等的两个对象，hashcode()一定相等； 
equals（）不相等的两个对象，却并不能证明他们的hashcode()不相等。换句话说，equals()方法不相等的两个对象，hashcode()有可能相等。（我的理解是由于哈希码在生成的时候产生冲突造成的）。 
反过来：hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等
hashCode方法默认返回对象的地址,String,Integer等封装类型对它进行了重写返回一个整数
该整数的取值来自于当前字符串的每个字母的编码值.公示如下
public int hashCode(){
	return “name”.hashCode();
}
s[0]表示当前字符串的第一个字母的编码值
s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
name = n + a + m + e
e.g n = 110  a = 97  m = 109  e = 31
int = 110*31^3+97*31^2….
	在Object类中定义了hashCode()方法和equals()方法，Object类的equals()方法按照内存地址比较对象是否相等，因
                  此如果object.equals(object2)为true, 则表明object1变量和object2变量实际上引用同一个对象，那么object1和
                  object2的哈希码也肯定相同。

                  为了保证HashSet能正常工作， 要求当两年对象用equals()方法比较的结果为true时，它们的哈希码也相等。如果用户
                  定义的Customer类覆盖了Object类的equals()方法，但是没有覆盖Object类的hashCode()方法，就会导致当
                  customer1.equals(customer2)为true时，而customer1和customer2的哈希码不一定一样，这会使HashSet无法正常工作。

                  public class Customer {
                         private String name;
                         private int age;

                         public Customer(String name, int age) {
                                this.name = name;
                                this.age = age;
                         }
                         
                         public String getName() {
                                return name;
                         }

                         public int getAge() {
                                return age;
                         }

                         public boolean equals(Object o) {
                                if(this==o) return true;                          
                                if(!(o instanceof Customer)) return false;
                                Customer other = (Customer)o;

                                if(this.name.equals(other.getName()) && this.age.equals(other.getAge())
                                      return true;
                                else 
                                      return false;

                         }
                  }

                  以下程序向HashSet中加入两个Customer对象。

                  Set set = new HashSet();
                  Customer customer1 = new Customer("Tom", 15);
                  Customer customer2 = new Customer("Tom", 15);
                  set.add(customer1);
                  set.add(customer2);
                  System.out.println(set.size());         //打印出 2

                  出现以上原因在于customer1和customer2的哈希码不一样，因此为两为customer对象计算出不同的位置，于是把它们放到集中中的不同的地方。

                  应加入以下hashCode()方法: 

                  public int hashCode() {
                         int result;
                         result = (name==null?0:name.hashCode());
                         result = 29*result + age;
                         return result;
                  }
               2) TreeSet

                  TreeSet实现了SortedSet接口，能够对集合中的对象进行排序。当TreeSet向集合中加入一个对象时，会把它插入到有序的对象序列中。那么TreeSet是如何对对象进行排序的呢？TreeSet支持两种排序方式：自然排序和客户化排序。默认情况下TreeSet采用的是自然排序方式：

                  a. 自然排序  升序

                     在JDK类库中， 有一部分类实现了Comparable接口，如Integer、Double和String等。Comparable接口有一个
                     compareTo(Object o)方法，它返回整数类型。对于x.comapreTo(y), 如
			x表示第一个值  y表示第二个值
                     返回0,       表明   x和y相等
                     返回值大于0, 表明   x>y
                     返回值小于0, 表明   x<y  -1

                     TreeSet调用对象的compareTo()方法比较集合中对象的大小，然后进行升序排序，这种排序方式称为自然排序。

                     ------------------------------------------------------------------------------------------------
                     JDK类库中实现了Comparable接口的一些类的排序方式： 

                     Byte, Short, Integer, Long, Double, Float     :         按数字大小排序；
                     Character                                     :         按字符的Unicode值的数字大小排序；
                     String                                        :         按字符串中字符的Unicode值排序；
                     ------------------------------------------------------------------------------------------------


                     使用自然排序， TreeSet中只能加入相同类型对象，且这些对象必须实现了Comparable接口。否则会抛出
                     ClassCastException异常。

                     当修改了对象的属性后， TreeSet不会重新排序。最适合TreeSet排序的是不可变类(它们的对象的属性不能修改)。

                  b. 客户化排序                

                     除了自然排序外， TreeSet还支持客户化排序。java.util.Comparator接口提供了具体的排序方法， 它有一个
                     compare(Object x, Object y)方法，用于比较两个对象的大小， 当compare(x,y)：

                     返回0,       表明   x和y相等
                     返回值大于0, 表明   x>y
                     返回值小于0, 表明   x<y

                     如果希望TreeSet按照Customer对象的name属性进行降序排列，可以先创建一个实现Comparator接口的类  
                     CustomerComparator, 参见：
		     使用compare(Object o1,Object o2)进行比较,
   		    一定要o1.compare(o2).如果想保持当前顺序,返回－1
		   如果想更改当前的顺序.返回1
		  e.g
		   compare(Object o1,Object o2) {
		         o1.compare(o2)>0 return -1 时 表示降序
 		         o1.compare(o2)<0  return 1 时 表示降序
		         o1.compare(o2)>0 return 1时 表示升序
		         o1.compare(o2)<0 return -1时 表示升序	     
		   }
                     import java.util.*;
                   
		     public class CustomerComparator implements Comparator {
                            public int compare(Object o1, Object o2) {
                                   Customer c1 = (Customer)o1;
                                   Customer c2 = (Customer)o2;
				    1   3    5  2  4    5 4 3 2 1
                                   if(c1.getName().compareTo(c2.getName())>0) return -1;
                                   if(c1.getName().compareTo(c2.getName())<0) return 1;

				   return 0;
                            }

                            public static void main(String[] args) {
                                   Set set = new TreeSet(new CustomerComparator());

                                   Customer customer1 = new Customer("Tom",15);
                                   Customer customer3 = new Customer("Jack",16);
                                   Customer customer2 = new Customer("Mike",26);
                                   set.add(customer1);
                                   set.add(customer2);
                                   set.add(customer3);

                                   Iterator it = set.iterator();
                      
                                   while(it.hasNext()) {
                                         Customer customer = it.next();
                                         System.out.println(customer.getName() + " " + customer.getAge());
                                   }
                             }
                      }

                      打印输出：

                      Tom 15
                      Mike 26
                      Jack 16

            3. List
 
               主要特征是其元素以线性方式存储，集合中允许存放重复对象。主要实现类包括：

               . ArrayList: 代表长度可变的数组。允许对元素进行快速的随机访问，但是向ArrayList中插入与删除元素的速度较慢；

               遍历方式：
               a. list.get(i);    //通过索引检索对象；
               b. Iterator it = list.iterator();
                  it.next();
		c.增强for循环
               
               讲解书上的例子；

            4. Map

               Map是一种把键对象和值对象进行映射的集合，它的每一个元素都包含一对键对象和值对象。向Map集合中加入元素时，
               必须提供一对键对象和值对象，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。

               map.put("2", "Tuesday");
               map.put("3", "Wednsday");
               map.put("4", "Thursday");

               String day = map.get("2");    //day的值为"Tuesday"

               Map集合中的键对象不允许重复，如以相同的键对象加入多个值对象，第一次加入的值对象将被覆盖。
               对于值对象则没有唯一性的要求，可以将任意多个键对象映射到同一个值对象上。

               map.put("1", "Mon");
               map.put("1", "Monday");      //"1"此时对应"Monday"
               map.put("one", "Monday");    //"one"此时对应"Monday"

               Map有两种比较常见的实现：

               1) HashMap

                  按哈希算法来存取键对象，有很好的存取性能，为了保证HashMap能正常工作，和HashSet一样，要求当两个键对象
                  通过equals()方法比较为true时，这两个键对象的hashCode()方法返回的哈希码也一样。

                  讲解书上例子。

               2) TreeMap

                  实现了SortedMap接口，能对键对象进行排序。和TreeSet一样，TreeMap也支持自然排序和客户化排序两种方式。

                  Map map = new TreeMap();
                  map.put("1", "Monday");
                  map.put("3", "Wednsday");
                  map.put("4", "Thursday");
                  map.put("2", "Tuesday");

                  Set keys = map.keySet();
                  Iterator it = keys.iterator();
                  while(it.hasNext()) {
                        String key = (String)it.next();
                        String value= (String)map.get(key);
                        System.out.println(key + " " + value);
                  }

                  打印输出：

                  1 Monday
                  2 Tuesday
                  3 Wednsday
                  4 Thursday

        九. 反射 

            提到反射可能会使我们联想到光学中的反射概念，在Java中又是另外一个概念：
            平时我们照镜子的时候，在镜子后面会有自己的影子，其实java中的反射也是类似的，一个类或者对象通过反射可以
            获得自身的对象，该对象是一个java.lang.Class 的对象(就像一个镜像文件)。

	     通过反射可以获取一个运行中的类的详细内容,注意事项
1>该类必须在运行状态
2>需要提供想要被获取的类的名称(package.class)
3>可以获得该类的所有内容(包括构造方法 属性 即使priavte修饰  方法)
4>可以模拟该类的所有内容
     模拟getName()  发现此时你通过setName()在给该类赋值。
     我就可以通过模拟的getName()来获取到你赋予的值   
            一个对象或者类获得自身的Class对象的过程称为反射。

            有两种方法可以获得自身的Class对象引用(对每一个被装载的类型(类或接口)，虚拟机都会为它创建一个
            java.lang.Class的实例)：
            1) Class c = Class.forName(“com.briup.ch06.Student”);	//虚拟机中没有该类的Class的实例对象
            
            注意：类和它所创建的所有对象通过反射获得的Class对象都是同一个，在这个例子中是com.briup.ch06.Student
	          这里可以参考例子com.briup.ch06.ClassTest.java

            反射可以让我们利用这个Class对象来获取和修改私有的变量和方法，不通过共有的方法去获得（原来我们例子都是通过
            一个public的方法来设置和获取私有的变量），可以破坏数据的封装性。
c.getModifiers() 返回的整数值
0:default 不显示内容
1:public
2:private
4:protect
	    c.getName():获取类名称
	    c.getModifiers():获得当前类的修饰符 返回int类型需要进行转换
			   Modifier.toString(c.getModifiers())
	    c.getDeclaredFields():获得当前类的所有属性 返回类型是field[]数组类型
	    c.getFields()只能返回public修饰的属性
	    AccessibleObject.setAccessible(field, true):如果版本低的idk想要获取private修饰的属性,需要修改
						访问控制可见度.true为全部可见
	    field[i].getModifiers():获得属性的修饰符,返回类型整形
	    field[i].getType().getName():获得属性的返回类型 String类型
	    c.getDeclaredConstructors():获得当前类型构造方法 返回是数组类型
	    cons[i].getParameterTypes():返回方法的参数类型
	    c.getMethods():返回当前类的所有方法
	    	    
	    反射：
            1) 确定一个对象的class
            2) 可以获得一个类的修饰符、字段、方法、构造器和父类。
            3) 获得接口声明的常量和方法。
            4) 创建Class的实例，直到运行时才获得。
            5) 运行前即使字段名字不知道，可以到程序运行时获得和修改这些字段的值。
            6) 运行前即使对象的方法名不知道，可以到程序运行时触发调用该方法。
            7) 运行前创建了一个大小和元素都未知的新数组，可以到运行时修改数组的元素。

            

       Review Questions: 

            1. (Level 1) What is the functionalities for initialization block?
                      答：初始化成员变量；
            2. (Level 1) What is abstract method and abstract class?
                      答：抽象方法：没有方法体的方法； 
                          抽象类：　不能直接实例化，用abstract关键字修饰的类；可以包含抽象方法；
            3. (Level 1) What is inside an interface?
                      答：public, static, final类型成员变量和public、abstract类型的成员方法；
            4. (Level 1) How many types of inner classes does Java have?
　　　　　　　　　　　答：四种。静态、实例、局部、匿名内部类
            5. (Level 1) What are the differences between Map, Set and List?
                      答：. Set : 无序，并且没有重复对象。
                          . List: 有序(放入的先后的次序), 可重复。
                          . Map : 集合中的每一个元素包含一对键对象和值对象，集合中没有重复的键对象，值对象可以重复。

            6. (Level 2) Which of the following statements are true?
                A. An inner class may be declared private.
                B. An inner class may be declared static.
                C. An inner class defined in a method should always be anonymous.
                D. An inner class defined in a method can access all the method local variables.
                   //能访问所在方法中的final类型的参数和变量。
                E. Construction of an inner class may require an instance of the outer class.
                答：A, B, E
            7. (Level 3) Consider the following definition:
               1. public class Outer{
               2.   public int a = 1;
               3.   public int b = 2;
               4.   public void method(final int c) {
               5.    Int d = 3;
               6.    Class Inner{
               7.      private void iMethod(int e) {
               8.  
               9.      }}}}
              Which variables can be referenced correctly at line 8?
               A. a     B. b     C. c     D. d     E. e 
              答：A, B, C, E
            8. (Level 2) Which would be most suitable for storing data elements that must not appear in the store 
               more than once, if searching is not a priority?
               A. Collection     B. List      C. Set      D. Map       E. Vector
               答：c
            9. (Level 3) In the following code fragment, line 4 is executed.
               1. String s1 = “XYZ”;
               2. String s2 = “XYZ”;
               3. If( s1 == s2) 
               4.     System.out.println(“Line 4);
                  A. True                  
                  B. False
               答：A


集合类似于数组都是用来存储数据
1.集合相对于数组而言  
  集合可以存放任意的类型,存放的内容可以类型不相同.而数组也可以
  存放任意的类型,但是同一个数组中包含的内容必须类型相同.
2.集合不需要执行长度,可以扩容
  数组开始需要制定长度,换言之不能进行随意的扩容操作.
  如果必须要进行扩容操作,只能进行重新构建数组操作.并且使用
  arraycopy()方法将原来数组中的内容复制到新构建的数组中
3.集合中有很jdk提供api,换言之可以直接拿来使用的方法.操作
  起来比数组方便. add()  size()  remove() get()

remove():参数如果跟的是对象,按照最先在集合中出现的位置从
	 第一个开始删除
  	 参数是索引,按照索引所指向的内容进行删除操作 
	 参数中的数据如果出现重复数据,调用remove()方法删除
	 第一个数据.
 	 尽量使用索引删除,不会产生歧义.





	















